using Mono.Cecil.Cil;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

public class MainScript : MonoBehaviour
{

    /*Static 개발자 설정(단 메인화면에서부터 시작해야 작동)
     *줌인, 인게임 카메라 이동속도등
     */
    //디버그모드
    public static bool MobilMode = true;
    //타일위의 기물들이 타일아래서 얼마만큼의 로컬위치에 있어야 자연스러운지 설정하는 곳.
    public static Vector3 LocalPositionOfPieceOntile = new Vector3(0, 0, 0);

    //개발자 설정 끝

    /*Static 유저 설정(단 메인화면에서부터 시작해야 작동)
     *소리크기, GUI비율등.
     */
    
    private void Start()
    {
        DontDestroyOnLoad(this);
    }
}
////6월5일. 앞으로 할 것: 유연하고 자연스러운 애니메이션 이벤트 처리와  프레임최적화를 위한 안정적인 스크립트 분할과 쓰레드이용.
////그리고 좀더 편한 마우스 조작.
//public class 오브젝트형
//{
//    public GameObject 오브젝트;
//    public void 오브젝트파괴()
//    {
//        MonoBehaviour.Destroy(오브젝트);
//    }
//}
//public class 기물형 : 오브젝트형
//{
//    public bool 구역통과여부 = true;//구역의 기본값
//    public bool 움직임여부 = true;
//    public int 공격력;//비전투 시설은 0으로 둔다.
//    public int 방어력;
//    public void 속성리셋()
//    {
//        공격력 = 2000;
//        방어력 = 500;
//    }
//}
//public class 아이템형 : 오브젝트형 //이후 좀더 다양한 아이템을 작성할 것.
//{
//    public int 회복력 = 400;
//}
//public class 구역 : 오브젝트형
//{
//    public int x;
//    public int y;
//    public 기물형 기물;
//    public 아이템형 아이템;
//    //지형도 추가.
//    public bool 통과체크()
//    {
//        if (Object.ReferenceEquals(기물,null)) return true;//구역에 기물이 없는 경우는 통과다. 지형의 경우는 또 모르겠다.
//        Debug.Log("기통" + 기물.구역통과여부.ToString());
//        Debug.Log("기물이름" + 기물.오브젝트.name);
//        return 기물.구역통과여부;
//    }
//    public void 게임오브젝트를구역에고정(GameObject temp)//이 함수는 언젠가 기물의 애니메이션 처리를 위해 사라져야함.
//    {
//        temp.transform.localPosition = 오브젝트.transform.localPosition;
//    }

//    public void 파괴판정후파괴()
//    {
//        if (기물.방어력 < 0)
//        {
//            Debug.Log("tyguiu");
//            기물.속성리셋();
//            기물.오브젝트파괴();
//        }
//    }
//}

//public partial class MainScript
//{

//    public GameObject[] 임시기물 = new GameObject[6];//temp
//    public GameObject[] 임시기물2 = new GameObject[6];//temp
//    public GameObject[] 임시아이템 = new GameObject[3];//temp
//    public GameObject[] 임시지형 = new GameObject[3];

//    public 구역[,] 맵 = new 구역[8, 8];
//    public GameObject MapObject;
//    public GameObject 타일;

//    void 맵생성(int width,int height)
//    {
//        //맵생성
//        for (int i = 0; i < width; i++) for (int j = 0; j < height; j++) 맵[i, j] = new 구역();
//        for (int i = 0; i < width; i++) for (int j = 0; j < height; j++)
//            {
//                맵[i, j].오브젝트 = Instantiate(타일);
//                맵[i, j].x = i;
//                맵[i, j].y = j;
//                맵[i, j].오브젝트.GetComponent<TileScript>().자기위치i = i;
//                맵[i, j].오브젝트.GetComponent<TileScript>().자기위치j = j;
//                맵[i, j].오브젝트.transform.parent = MapObject.transform;
//                맵[i, j].오브젝트.transform.localScale = new Vector3(1, 1, 0);
//                맵[i, j].오브젝트.transform.localPosition = new Vector3(i, j, 0);
//            }
//        타일.GetComponent<SpriteRenderer>().enabled = false;
//        타일.GetComponent<BoxCollider2D>().enabled = false;
//    }
//    void 임시기물생성()//파일 입출력으로 처리해야한다.
//    {
//        for (int i = 0; i < 8; i++)
//        {
//            맵[i, 1].기물 = new 기물형();//메모리 할당하고
//            맵[i, 1].기물.속성리셋();//그냥 해주고
//            맵[i, 1].기물.오브젝트 = Instantiate(임시기물[5]);//오브젝트 넣어주고
//            맵[i, 1].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//            맵[i, 1].게임오브젝트를구역에고정(맵[i, 1].기물.오브젝트);//위치를 바꿔준다.
//        }
//        맵[0, 0].기물 = new 기물형();//메모리 할당하고
//        맵[0, 0].기물.속성리셋();//그냥 해주고
//        맵[0, 0].기물.오브젝트 = Instantiate(임시기물[4]);//오브젝트 넣어주고
//        맵[0, 0].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[0, 0].게임오브젝트를구역에고정(맵[0, 0].기물.오브젝트);//위치를 바꿔준다.

//        맵[7, 0].기물 = new 기물형();//메모리 할당하고
//        맵[7, 0].기물.속성리셋();//그냥 해주고
//        맵[7, 0].기물.오브젝트 = Instantiate(임시기물[4]);//오브젝트 넣어주고
//        맵[7, 0].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[7, 0].게임오브젝트를구역에고정(맵[7, 0].기물.오브젝트);//위치를 바
//                                              //꿔준다.

//        맵[1, 0].기물 = new 기물형();//메모리 할당하고
//        맵[1, 0].기물.속성리셋();//그냥 해주고
//        맵[1, 0].기물.오브젝트 = Instantiate(임시기물[0]);//오브젝트 넣어주고
//        맵[1, 0].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[1, 0].게임오브젝트를구역에고정(맵[1, 0].기물.오브젝트);//위치를 바꿔준다.

//        맵[6, 0].기물 = new 기물형();//메모리 할당하고
//        맵[6, 0].기물.속성리셋();//그냥 해주고
//        맵[6, 0].기물.오브젝트 = Instantiate(임시기물[0]);//오브젝트 넣어주고
//        맵[6, 0].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[6, 0].게임오브젝트를구역에고정(맵[6, 0].기물.오브젝트);//위치를 바꿔준다.


//        맵[2, 0].기물 = new 기물형();//메모리 할당하고
//        맵[2, 0].기물.속성리셋();//그냥 해주고
//        맵[2, 0].기물.오브젝트 = Instantiate(임시기물[1]);//오브젝트 넣어주고
//        맵[2, 0].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[2, 0].게임오브젝트를구역에고정(맵[2, 0].기물.오브젝트);//위치를 바꿔준다.

//        맵[5, 0].기물 = new 기물형();//메모리 할당하고
//        맵[5, 0].기물.속성리셋();//그냥 해주고
//        맵[5, 0].기물.오브젝트 = Instantiate(임시기물[1]);//오브젝트 넣어주고
//        맵[5, 0].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[5, 0].게임오브젝트를구역에고정(맵[5, 0].기물.오브젝트);//위치를 바꿔준다.


//        맵[3, 0].기물 = new 기물형();//메모리 할당하고
//        맵[3, 0].기물.속성리셋();//그냥 해주고
//        맵[3, 0].기물.오브젝트 = Instantiate(임시기물[2]);//오브젝트 넣어주고
//        맵[3, 0].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[3, 0].게임오브젝트를구역에고정(맵[3, 0].기물.오브젝트);//위치를 바꿔준다.

//        맵[4, 0].기물 = new 기물형();//메모리 할당하고
//        맵[4, 0].기물.속성리셋();//그냥 해주고
//        맵[4, 0].기물.오브젝트 = Instantiate(임시기물[3]);//오브젝트 넣어주고
//        맵[4, 0].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[4, 0].게임오브젝트를구역에고정(맵[4, 0].기물.오브젝트);//위치를 바꿔준다.
//        for (int i = 0; i < 8; i++)
//        {
//            맵[i, 6].기물 = new 기물형();//메모리 할당하고
//            맵[i, 6].기물.속성리셋();//그냥 해주고
//            맵[i, 6].기물.오브젝트 = Instantiate(임시기물2[5]);//오브젝트 넣어주고
//            맵[i, 6].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//            맵[i, 6].게임오브젝트를구역에고정(맵[i, 6].기물.오브젝트);//위치를 바꿔준다.
//        }
//        맵[0, 7].기물 = new 기물형();//메모리 할당하고
//        맵[0, 7].기물.속성리셋();//그냥 해주고
//        맵[0, 7].기물.오브젝트 = Instantiate(임시기물2[4]);//오브젝트 넣어주고
//        맵[0, 7].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[0, 7].게임오브젝트를구역에고정(맵[0, 7].기물.오브젝트);//위치를 바꿔준다.

//        맵[7, 7].기물 = new 기물형();//메모리 할당하고
//        맵[7, 7].기물.속성리셋();//그냥 해주고
//        맵[7, 7].기물.오브젝트 = Instantiate(임시기물2[4]);//오브젝트 넣어주고
//        맵[7, 7].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[7, 7].게임오브젝트를구역에고정(맵[7, 7].기물.오브젝트);//위치를 바
//                                              //꿔준다.

//        맵[1, 7].기물 = new 기물형();//메모리 할당하고
//        맵[1, 7].기물.속성리셋();//그냥 해주고
//        맵[1, 7].기물.오브젝트 = Instantiate(임시기물2[0]);//오브젝트 넣어주고
//        맵[1, 7].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[1, 7].게임오브젝트를구역에고정(맵[1, 7].기물.오브젝트);//위치를 바꿔준다.

//        맵[6, 7].기물 = new 기물형();//메모리 할당하고
//        맵[6, 7].기물.속성리셋();//그냥 해주고
//        맵[6, 7].기물.오브젝트 = Instantiate(임시기물2[0]);//오브젝트 넣어주고
//        맵[6, 7].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[6, 7].게임오브젝트를구역에고정(맵[6, 7].기물.오브젝트);//위치를 바꿔준다.


//        맵[2, 7].기물 = new 기물형();//메모리 할당하고
//        맵[2, 7].기물.속성리셋();//그냥 해주고
//        맵[2, 7].기물.오브젝트 = Instantiate(임시기물2[1]);//오브젝트 넣어주고
//        맵[2, 7].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[2, 7].게임오브젝트를구역에고정(맵[2, 7].기물.오브젝트);//위치를 바꿔준다.

//        맵[5, 7].기물 = new 기물형();//메모리 할당하고
//        맵[5, 7].기물.속성리셋();//그냥 해주고
//        맵[5, 7].기물.오브젝트 = Instantiate(임시기물2[1]);//오브젝트 넣어주고
//        맵[5, 7].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[5, 7].게임오브젝트를구역에고정(맵[5, 7].기물.오브젝트);//위치를 바꿔준다.


//        맵[3, 7].기물 = new 기물형();//메모리 할당하고
//        맵[3, 7].기물.속성리셋();//그냥 해주고
//        맵[3, 7].기물.오브젝트 = Instantiate(임시기물2[2]);//오브젝트 넣어주고
//        맵[3, 7].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[3, 7].게임오브젝트를구역에고정(맵[3, 7].기물.오브젝트);//위치를 바꿔준다.

//        맵[4, 7].기물 = new 기물형();//메모리 할당하고
//        맵[4, 7].기물.속성리셋();//그냥 해주고
//        맵[4, 7].기물.오브젝트 = Instantiate(임시기물2[3]);//오브젝트 넣어주고
//        맵[4, 7].기물.오브젝트.transform.parent = MapObject.transform;//상속시켜준다음
//        맵[4, 7].게임오브젝트를구역에고정(맵[4, 7].기물.오브젝트);//위치를 바꿔준다.
//    }
//}


//public partial class MainScript : MonoBehaviour
//{

//    void Start()
//    {
//        맵생성(9,9);
//        임시기물생성();//temp

//        임시지형[0].SetActive(false);
//    }

//    void Update()
//    {
//        마우스입력();
//    }
//    public int 선택모드;
//    public Vector2Int 위치;//<-타일스크립트에서 실시간으로 값바뀜
//    Vector2Int 이동시킬위치;
//    Vector2Int 기물구역위치;
//    public void 마우스입력()//한번에 두가지 이상의 기물을 클릭하면 오류. 선택모드가 1에서 멈추는 오류.
//    {
//        //230706 선택모드체계에 문제있음.
//        if (Input.GetMouseButtonDown(0))
//        {
//            //대기->0
//            //기물선택함->1
//            //위치선택함->0
//            if (선택모드 == 0)
//            {
//                기물구역위치 = 위치;
//                선택모드 = 1;
//            }
//            else if (선택모드 == 1)//원래있던 자리를 클릭하면 원래대로 되돌아간다.
//            {
//                if (위치 != 기물구역위치)//선택한 위치와 기물위치가 달라야 이동함수를 호출하지않는다
//                {
//                    이동시킬위치 = 위치;
//                    이동(맵[기물구역위치.x, 기물구역위치.y], 맵[이동시킬위치.x, 이동시킬위치.y]);
//                    선택모드 = 0;
//                }
//                //선택한 위치와 같은 기물위치를 클릭하면 재차 선택모드는 유지되고 재차 다른 구역을 클릭하면 기물이 옮겨진다. 
//            }
//        }
//    }
//    void 이동(구역 기물구역, 구역 위치구역)
//    {
//        Debug.Log(1);
//        if (이동규칙(기물구역, 위치구역) && 위치구역.통과체크() && 기물구역.기물 != null)
//        {
//            Debug.Log(2);
//            if (기물구역.기물.움직임여부)//이걸 한칸 밖에서 체크하면 할당되지않은 기물 인스턴스에 접근하는게 되서 오류가 된다.
//            {
//                Debug.Log(3);
//                if (위치구역.기물 == null)//위치구역에 기물이 없다면 그냥 이동
//                {
//                    Debug.Log(3);
//                    이동시의이벤트처리(위치구역, 기물구역.기물);
//                    위치구역.기물 = 기물구역.기물;
//                    기물구역.기물 = null;
//                    //기물구역의 기물이 위치구역으로 이동했음으로 위치구역의 위치고정함수를 호출하는 것이다.
//                    위치구역.게임오브젝트를구역에고정(위치구역.기물.오브젝트);
//                }
//                else//기물이 있다면 공방하고 이기면 이동.
//                {
//                    Debug.Log(4);
//                    int 방어자체력 = 공격방어계산처리(기물구역.기물, 위치구역.기물);//(공격자, 방어자)
//                    Debug.Log(방어자체력);
//                    //if(방어자체력>=0)//방어자가 승리하면 이동하지 않는다.
//                    if (방어자체력 < 0)//방어자가 터지면 이동
//                    {
//                        이동시의이벤트처리(위치구역, 기물구역.기물);
//                        위치구역.파괴판정후파괴();
//                        위치구역.기물 = 기물구역.기물;
//                        기물구역.기물 = null;
//                        //기물구역의 기물이 위치구역으로 이동했음으로 위치구역의 위치고정함수를 호출하는 것이다.
//                        위치구역.게임오브젝트를구역에고정(위치구역.기물.오브젝트);
//                    }
//                }
//            }
//        }
//    }
//    public bool 이동규칙(구역 기물구역, 구역 위치구역)//기물종류를 매개변수로 받아 서로 다른 이동 규칙을 설정하는 식으로 발전시키기.
//    {
//        return true;
//        //임시규칙:상하좌우 1칸씩만 이동가능.
//        int temp1 = 기물구역.x - 위치구역.x;
//        int temp2 = 기물구역.y - 위치구역.y;
//        if (temp1 < 0) temp1 = -temp1;
//        if (temp2 < 0) temp2 = -temp2;
//        if ((temp1 <= 1 && temp2 == 0) || (temp1 == 0 && temp2 <= 1))
//        {
//            return true;
//        }
//        //return false;
//        return false;

//    }
//    public void 이동시의이벤트처리(구역 통행할구역, 기물형 효과받을기물)//통행가능한지 체크해서 bool값넘갸주고 아이템먹으면 효과처리하는 친구.
//    {
//        if (통행할구역.아이템 != null)//통행할 구역에 아이템이 있으면
//        {
//            효과받을기물.방어력 += 통행할구역.아이템.회복력;

//            통행할구역.아이템.오브젝트파괴();
//            통행할구역.아이템 = null;
//        }
//    }
//    int 공격방어계산처리(기물형 공격자, 기물형 방어자)
//    {
//        int 방어자체력 = 0;
//        if (공격자.오브젝트 != null && 방어자.오브젝트 != null)//그냥하는 검사
//        {
//            방어자체력 = 방어자.방어력 - 공격자.공격력;
//            방어자.방어력 -= 공격자.공격력;
//        }
//        else print("공격방어계산처리함수");//예외처리
//        return 방어자체력;
//    }

//}





















//기물들만 따로 모아놓은 참조메모리하나<--사용자조작없이도 움직이는 기물의 작동을 위함.
//맵전체의 정보를 모아놓은 메모리하나;
//명령어를 받고 정리하고 관리하고 실행하는 함수하나
//그 함수의 명령에 따라 위 메모리 값들을 변경하는 함수하나


//기물여러개가 한 타일 안에 겹치면 세세한 위치를 달리 해야한다.
//맵 클래스 안에 기물들을 올려두는 것은 기물과 자원에 대한 원활한 엑세스와 공격판정을 위해 필요하다
//유저의 조작방법
//1.원클릭으로 타일선택
//타일선택시 기물선택(



//public void 명령처리()//아니, 명령처리는 함수가 아니라 클래스로 하고, 업데이트 문에서 명령처리 클래스 인스턴스 객체에
//    //있는 명령어 실행 리스트를 스캔해서 순차적으로 실행한다. 명령처리 클래스는 명령의 기록, 취소, 저장, 되돌리기, 등등, 명령처리의 허브역할을 한다.
//{
//    //기물선택과 이동
//    bool 기물선택=false;

//}